// 기본적으로 Varable & Operator만 있으면 코딩 가능.
// 나머지는 부가적인 것들.
package main

import (
	"fmt"
	"math"
)

func equal(a, b float64) bool {
	return math.Nextafter(a, b) == b
}

func main() {
	var x int8 = 4
	var y int8 = 64

	fmt.Printf("x: %08b x << 2: %08b x << 2: %d\n", x, x << 2, x << 2) // x: 00000100 x << 2: 00010000 x << 2: 16
	fmt.Printf("y: %08b y << 2: %08b y << 2: %d\n", y, y << 2, y << 2) // y: 01000000 y << 2: 00000000 y << 2: 0

	var a int8 = 16
	var b int8 = -128
	var c int8 = -1
	var d uint8 = 128

	fmt.Printf("a: %08b a >> 2: %08b a >> 2: %d\n", a, a >> 2, a >> 2) // a: 00010000 a >> 2: 00000100 a >> 2: 4
	fmt.Printf("b: %08b b >> 2: %08b b >> 2: %d\n", uint8(b), uint8(b >> 2), b >> 2) // b: 10000000 b >> 2: 11100000 b >> 2: -32
	fmt.Printf("c: %08b c >> 2: %08b c >> 2: %d\n", uint8(c), uint8(c >> 2), c >> 2) // c: 11111111 c >> 2: 11111111 c >> 2: -1
	fmt.Printf("d: %08b d >> 2: %08b d >> 2: %d\n", d, d >> 2, d >> 2) // d: 00000128 d >> 2: 00000032 d >> 2: 32

	var aa float64 = 0.1
	var bb float64 = 0.2
	var cc float64 = 0.3

	fmt.Printf("%.18f == %0.18f : %v\n", cc, aa + bb, equal(aa + bb, cc))
}


// 산술 연산자
// => 사칙 연산과 나머지
// +: 더하기
// -: 뺴기
// *: 곱하기
// /: 나누기
// %: 나머지

// => 비트 연산 // 2진법으로 계산
// &: AND 비트 연산 => 두 비트 모두 1인 경우 1반환
// |: OR 비트 연산 => 두 비트 중 하나만 1이어도 1반환 
// ^: XOR 비트 연산 => 두 비트가 같을 경우 1반환 
// * 다른 언어에서는 기호^가 승수를 의미하기도 하지만, Go에서는 XOR 비트 연산을 의미
// 승수를 사용하고 싶을 경우 package math.Pow를 사용해야 함
// &^: 비트 클리어

// => 시프트 연산
// <<: 비트를 왼쪽으로 밀어냄 ex: 10 << 2 => 2진법 10을 비트 왼쪽으로 밀어냄
// 왼쪽으로 2비트 밀어낼 경우 빈 값은 0으로(기본 값이 음수일 경우 1) 채워지며, 바뀐 값은 원래 값의 2배
// MSB가 채워져있을 경우 overflow 발생
// >>: 비트를 오른쪽으로 밀어냄
// 오른으로 2비트 밀어낼 경우 빈 값은 0으로(기본 값이 음수일 경우 1)c; 채워지며, 바뀐 값은 원래 값의 1/2
// // LSB가 채워져있을 경우 overflow 발생

// => 비교 연산
// ==: 두 비트가 같은지 비교
// !=: 두 비트가 다른지 비교
// >, < >=, <=: 일반적인 기호와 동일한 의미

// 논리 연산자
// &&: AND 두 변이 모두 true 일 경우 true 반환
// ||: OR 두 변 중 하나라도 true 일 경우 true 반환
// !: NOT true이면 false 반환, false면 true 반환

// 대입 연산자
// =: 좌변의 기호에 우변에 값을 대입
// a, b = b, a => a에 b 값을 대입

// 증감연산자 
// ++, --